/*	RoadPathfinder v.6 r.77 [2011-04-15], originally part of 
 *	WmDOT v.4  r.50 [2011-04-06]
 *	Copyright © 2011 by W. Minchin. For more info,
 *		please visit http://openttd-noai-wmdot.googlecode.com/
 */
 
/*	These are files that supplimentary to the Road Pathfinder itself, but will
 *		hopefully prove useful either directly or as a model for writing your
 *		own functions. They include:
 *	- Info class - useful for outputing the details fo the library to the debug
 *		screen
 *	- Build function - used to build the path generated by the pathfinder
 *	- Cost function - used to determine the cost of building the path generated
 *		by the pathfinder
 *	- Length - used to determine how long the generated path is
 *	- Presets - a combination of settings for the pathfinder for using it in
 *		different circumstances
 *		- Original - the settings in the original (v3) pathfinder by NoAI Team
 *		- PerfectPath - my slighlty updated version of Original. Good for
 *			reusing exisiting roads
 *		- Dirty - quick but messy preset. Runs in as little as 5% of the time
 *			of 'PerfectPath', but builds odd bridges and loops
 *		- ExistingCheck - based on PerfectPath, but uses only exising roads.
 *			Useful for checking if there an exisiting route and how long it is
 *		- Streetcar - reserved for future use for intraurban tram lines
 *		If you would like a preset added here, I would be happy to include it
 *			in future versions!
 */
 
 
class Road.Info {
	function GetVersion()       { return 6; }
	function GetMinorVersion()	{ return 0; }
	function GetRevision()		{ return 77; }
	function GetDate()          { return "2011-04-15"; }
	function GetName()          { return "Road Pathfinder (Wm)"; }
}

class Road.Presets {
	function Original() {
	//	the settings in the original (v3) pathfinder by NoAI Team
		this._max_cost = 10000000;
		this._cost_tile = 100;
		this._cost_no_existing_road = 40;
		this._cost_turn = 100;
		this._cost_slope = 200;
		this._cost_bridge_per_tile = 150;
		this._cost_tunnel_per_tile = 120;
		this._cost_coast = 20;
		this._max_bridge_length = 10;
		this._max_tunnel_length = 20;
		this._cost_only_existing_roads = false;
		this._distance_penalty = 1;
		return;
	}
	function PerfectPath() {
	//	my slighlty updated version of Original. Good for reusing exisiting
	//		roads
		this._max_cost = 100000;
		this._cost_tile = 30;
		this._cost_no_existing_road = 40;
		this._cost_turn = 100;
		this._cost_slope = 200;
		this._cost_bridge_per_tile = 150;
		this._cost_tunnel_per_tile = 120;
		this._cost_coast = 20;
		this._max_bridge_length = 10;
		this._max_tunnel_length = 20;
		this._cost_only_existing_roads = false;
		this._distance_penalty = 1;
		return;
	}
	function Dirty() {
	//	quick but messy preset. Runs in as little as 5% of the time of
	//		'PerfectPath', but builds odd bridges and loops
		this._max_cost = 100000;
		this._cost_tile = 30;
		this._cost_no_existing_road = 301;
		this._cost_turn = 50;
		this._cost_slope = 150;
		this._cost_bridge_per_tile = 750;
		this._cost_tunnel_per_tile = 120;
		this._cost_coast = 20;
		this._max_bridge_length = 16;
		this._max_tunnel_length = 10;
		this._cost_only_existing_roads = false;
		this._distance_penalty = 5;
		return;
	}
	function ExistingCheck() {
	//	based on PerfectPath, but uses only exising roads. Useful for checking
	//		if there an exisiting route and how long it is
		this._max_cost = 100000;
		this._cost_tile = 30;
		this._cost_no_existing_road = 40;
		this._cost_turn = 100;
		this._cost_slope = 200;
		this._cost_bridge_per_tile = 150;
		this._cost_tunnel_per_tile = 120;
		this._cost_coast = 20;
		this._max_bridge_length = 9999;
		this._max_tunnel_length = 9999;
		this._cost_only_existing_roads = true;
		this._distance_penalty = 1;
		return;
	}
	function Streetcar () {
	//	reserved for future use for intraurban tram lines
		return;
	}

}

function Road::GetPathBuildCost()
{
//	Turns to 'test mode,' builds the route provided, and returns the cost (all
//		money for AI's is in British Pounds)
//	Note that due to inflation, this value can get stale
//	Returns false if the test build fails somewhere

	if (this._main._running) {
		AILog.Warning("You can't find the build costs while there's a running pathfinder.");
		return false;
	}
	if (this._mypath == null) {
		AILog.Warning("You have tried to get the build costs of a 'null' path.");
		return false;
	}
	
	local BeanCounter = AIAccounting();
	local TestMode = AITestMode();
	local Path = this._mypath;

	AIRoad.SetCurrentRoadType(this._RoadType);
	while (Path != null) {
		local SubPath = Path.GetParent();
		if (SubPath != null) {
			local Node = Path.GetTile();
			if (AIMap.DistanceManhattan(Path.GetTile(), SubPath.GetTile()) == 1) {
			//	MD == 1 == road joining the two tiles
				if (!AIRoad.BuildRoad(Path.GetTile(), SubPath.GetTile())) {
				//	If we get here, then the road building has failed
				//	Possible that the road already exists
				//	TO-DO
				//	- fail the road builder if the road cannot be built and
				//		does not already exist
				//	return null;
				}
			} else {
			//	Implies that we're building either a tunnel or a bridge
				if (!AIBridge.IsBridgeTile(Path.GetTile()) && !AITunnel.IsTunnelTile(Path.GetTile())) {
					if (AIRoad.IsRoadTile(Path.GetTile())) {
					//	Original example demolishes tile if it's already a road
					//		tile to get around expanded roadbits.
					//	I don't like this approach as it could destroy Railway
					//		tracks/tram tracks/station
					//	TO-DO
					//	- figure out a way to do this while keeping the other
					//		things I've built on the tile
					//	(can I just remove the road?)
						AITile.DemolishTile(Path.GetTile());
					}
					if (AITunnel.GetOtherTunnelEnd(Path.GetTile()) == SubPath.GetTile()) {
						if (!AITunnel.BuildTunnel(AIVehicle.VT_ROAD, Path.GetTile())) {
						//	At this point, an error has occured while building the tunnel.
						//	Fail the pathfiner
						//	return null;
						Log.Warning("OpDOT::GetPathBuildCost can't build a tunnel from " + AIMap.GetTileX(Path.GetTile()) + "," + AIMap.GetTileY(Path.GetTile()) + " to " + AIMap.GetTileX(SubPath.GetTile()) + "," + AIMap.GetTileY(SubPath.GetTile()) + "!!" );
						}
					} else {
					//	if not a tunnel, we assume we're buildng a bridge
						local BridgeList = AIBridgeList_Length(AIMap.DistanceManhattan(Path.GetTile(), SubPath.GetTile() + 1));
						BridgeList.Valuate(AIBridge.GetMaxSpeed);
						BridgeList.Sort(AIAbstractList.SORT_BY_VALUE, false);
						if (!AIBridge.BuildBridge(AIVehicle.VT_ROAD, BridgeList.Begin(), Path.GetTile(), SubPath.GetTile())) {
						//	At this point, an error has occured while building the bridge.
						//	Fail the pathfiner
						//	return null;
						Log.Warning("OpDOT::GetPathBuildCost can't build a bridge from " + AIMap.GetTileX(Path.GetTile()) + "," + AIMap.GetTileY(Path.GetTile()) + " to " + AIMap.GetTileX(SubPath.GetTile()) + "," + AIMap.GetTileY(SubPath.GetTile()) + "!!" );
						}
					}
				}
			}
		}
	Path = SubPath;
	}
	
	//	End build sequence
		return BeanCounter.GetCosts();
}

function Road::BuildPath()
{
	if (this._main._running) {
		AILog.Warning("You can't build a path while there's a running pathfinder.");
		return false;
	}
	if (this._mypath == null) {
		AILog.Warning("You have tried to build a 'null' path.");
		return false;
	}
	
	local TestMode = AIExecMode();	//	We're really doing this!
	local Path = this._mypath;

	AIRoad.SetCurrentRoadType(this._RoadType);
	while (Path != null) {
		local SubPath = Path.GetParent();
		if (SubPath != null) {
			local Node = Path.GetTile();
			if (AIMap.DistanceManhattan(Path.GetTile(), SubPath.GetTile()) == 1) {
			//	MD == 1 == road joining the two tiles
				if (!AIRoad.BuildRoad(Path.GetTile(), SubPath.GetTile())) {
				//	If we get here, then the road building has failed
				//	Possible that the road already exists
				//	TO-DOz
				//	- fail the road builder if the road cannot be built and
				//		does not already exist
				//	return null;
				}
			} else {
			//	Implies that we're building either a tunnel or a bridge
				if (!AIBridge.IsBridgeTile(Path.GetTile()) && !AITunnel.IsTunnelTile(Path.GetTile())) {
					if (AIRoad.IsRoadTile(Path.GetTile())) {
					//	Original example demolishes tile if it's already a road
					//		tile to get around expanded roadbits.
					//	I don't like this approach as it could destroy Railway
					//		tracks/tram tracks/station
					//	TO-DO
					//	- figure out a way to do this while keeping the other
					//		things I've built on the tile
					//	(can I just remove the road?)
						AITile.DemolishTile(Path.GetTile());
					}
					if (AITunnel.GetOtherTunnelEnd(Path.GetTile()) == SubPath.GetTile()) {
					//	The assumption here is that the land hasn't changed
					//		from when the pathfinder was run and when we try to
					//		build the path. If the tunnel building fails, we
					//		get the 'can't build tunnel' message, but if the
					//		land has changed such that the tunnel end is at a
					//		different spot than is was when the pathfinder ran,
					//		we skip tunnel building and try and build a bridge
					//		instead, which will fail because the slopes are wrong...
						if (!AITunnel.BuildTunnel(AIVehicle.VT_ROAD, Path.GetTile())) {
						//	At this point, an error has occured while building the tunnel.
						//	Fail the pathfiner
						//	return null;
							Log.Warning("OpDOT::BuildPath can't build a tunnel from " + AIMap.GetTileX(Path.GetTile()) + "," + AIMap.GetTileY(Path.GetTile()) + " to " + AIMap.GetTileX(SubPath.GetTile()) + "," + AIMap.GetTileY(SubPath.GetTile()) + "!!" );
						}
					} else {
					//	if not a tunnel, we assume we're buildng a bridge
						local BridgeList = AIBridgeList_Length(AIMap.DistanceManhattan(Path.GetTile(), SubPath.GetTile() + 1));
						BridgeList.Valuate(AIBridge.GetMaxSpeed);
						BridgeList.Sort(AIAbstractList.SORT_BY_VALUE, false);
						if (!AIBridge.BuildBridge(AIVehicle.VT_ROAD, BridgeList.Begin(), Path.GetTile(), SubPath.GetTile())) {
						//	At this point, an error has occured while building the bridge.
						//	Fail the pathfiner
						//	return null;
						Log.Warning("OpDOT::BuildPath can't build a bridge from " + AIMap.GetTileX(Path.GetTile()) + "," + AIMap.GetTileY(Path.GetTile()) + " to " + AIMap.GetTileX(SubPath.GetTile()) + "," + AIMap.GetTileY(SubPath.GetTile()) + "!! (or the tunnel end moved...)" );
						}
					}
				}
			}
		}
	Path = SubPath;
	}
	
	//	End build sequence
	return true;
}

